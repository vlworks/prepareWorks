# Домашнее задание №2

## Какие типы паттернов проектирования существуют?
Так то их полно, но я лично сталкивался пока что с MVC, ActiveRecord, Facade, Singleton

## Задание 2. Как можно улучшить Singleton при помощи trait-ов?
Получается что Singleton применяется к самому классу и не использует наседований. И если создавать несколько классов с Singleton, то придется для каждого прописывать свои методы. А если методы повторяются? Что в 1 что в 2 классе, а наследоваться нельзя - можно дополнить их трейтами. Множественное наследование.

## Задание 3. Как реализуется паттерн Фабричный метод? В чем его отличие от паттерна Фабрика?
Фабричный метод - это паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, **позволяя подклассам изменять тип создаваемых объектов** - собственно вот оно и отличие.

## Задание 4. Объясните назначение и применение магических методов __get, __set, __isset, __unset, __call и __callStatic. Когда, как и почему их стоит использовать (или нет)?

__get и __set - могут использоваться при работе с защищенными свойствами, через них, а не на прямую можно реализовать получение\изменение свойства объекта и доболнить к примеру функционалом логирования

__isset и __unset  - применяют функции isset(), empty() и unset() - для защищенных свойствах  

__call и __callStatic - запускается при вызове недоступных методов в контексте объект и в статическом контексте.

## Задание 5. Опишите несколько структур данных из стандартной библиотеки PHP (SPL). Приведите примеры использования.

```
spl_autoload_register - можно использовать как свой загрузчик классов чтобы подтягивать только используемые классы

FilesystemIterator - мы на нем писали свой Проводник

ArrayIterator - использоваил для работы с большими массивами, много готового функционала котоырй в разы быстрее и позволяет не изобретаь велосипед
```

## Задание 6. Найдите все ошибки в коде:

```
interface MyInt {
    public function funcI();
    private function funcP(); // приватный метод в интерфейсе
} 
class A {
    protected prop1;
    private prop2;

    function funcA(){
       return $this->prop2;
    }
}
class B extends A {
    function funcB(){
       return $this->prop1;
    }
}
class C extends B implements MyInt { // используется риализация метода а не переопределение суперкласса
    function funcB(){
       return $this->prop1;
    }
    private function funcP(){
       return 123;
    }
}  
$b = new B();
$b->funcA();
$c = new C();
$c->funcI();
```